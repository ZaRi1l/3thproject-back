# 워크플로우의 이름을 지정합니다. GitHub 저장소의 "Actions" 탭에 이 이름이 표시됩니다.
name: Backend CI/CD Pipeline

# ===================================================================
#  1. 워크플로우 실행 조건 (Trigger)
# ===================================================================
# 'main' 브랜치와 관련된 특정 이벤트가 발생했을 때 이 워크플로우를 실행합니다.
on:
  # 1. main 브랜치에 직접 push 할 때
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'  # 모든 마크다운 파일 무시
      - 'docs/**'  # docs 폴더 아래의 모든 변경 무시

  # 2. main 브랜치로 Pull Request가 merge 될 때
  pull_request:
    types: [ closed ] # PR이 닫혔을 때 (merged 또는 unmerged)
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'

# ===================================================================
#  2. 실행될 작업 (Jobs)
# ===================================================================
jobs:
  # 'build-and-deploy' 라는 이름의 작업을 정의합니다.
  build-and-deploy:
    # ★★★ 중요: 이 작업은 'push' 이벤트이거나, 'pull_request'가 "병합(merged)"되면서 닫혔을 때만 실행됩니다.
    # (코드가 변경되지 않고 그냥 PR만 닫는 경우에는 실행되지 않도록 하는 안전장치입니다.)
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    # 이 작업은 GitHub가 제공하는 최신 우분투(Ubuntu) 가상 서버에서 실행됩니다.
    runs-on: ubuntu-latest

    # 작업 안에서 순서대로 실행될 단계(Steps)들을 정의합니다.
    steps:
      # -------------------------------------------------------------------
      #  단계 1: 소스 코드 및 환경 준비
      # -------------------------------------------------------------------
      # GitHub 저장소의 소스 코드를 가상 서버 안으로 내려받습니다(Checkout).
      - name: Checkout Source Code
        uses: actions/checkout@v3

      # Gradle 빌드를 위해 JDK 24 환경을 설정합니다. (명시성 및 나중의 테스트 단계 추가 등 확장성을 위해 포함)
      - name: Set up JDK 24
        uses: actions/setup-java@v3
        with:
          java-version: '24'
          distribution: 'temurin'

      # -------------------------------------------------------------------
      #  단계 2: Docker 이미지 빌드 및 Docker Hub에 업로드
      # -------------------------------------------------------------------
      # GitHub Secrets에 저장된 정보를 사용하여 Docker Hub에 로그인합니다.
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Dockerfile을 사용하여 이미지를 빌드하고, Docker Hub 레포지토리로 푸시(업로드)합니다.
      # 이 과정 안에서 Dockerfile의 지시에 따라 자동으로 Gradle 빌드(.jar 생성)가 일어납니다.
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          # 이미지 태그: [DockerHub아이디]/[레포지토리명]:latest 형식
          # ★★★★★ 'my-app-backend'를 본인이 Docker Hub에 만든 레포지토리 이름으로 수정하세요! ★★★★★
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/3thproject-back:latest
          no-cache: true  # 캐시 안씀

      # -------------------------------------------------------------------
      #  단계 3: EC2 서버에 배포
      # -------------------------------------------------------------------
      # EC2 서버에 SSH로 원격 접속하여 배포 스크립트를 실행합니다.
      - name: Deploy to EC2 Instance
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.AWS_HOST_IP }}
          username: ${{ secrets.AWS_HOST_USERNAME }}
          key: ${{ secrets.AWS_SSH_PRIVATE_KEY }}
          # EC2 서버에 접속해서 실행할 명령어들을 순서대로 나열합니다.
          script: |
            cd ~/app
            
            # EC2 서버의 docker-compose.yml이 사용할 수 있도록 환경변수를 export 합니다.
            # 이 환경변수들은 이 스크립트가 실행되는 동안에만 유효합니다.
            export DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            export DB_USERNAME_PROD=${{ secrets.DB_USERNAME_PROD }}
            export DB_PASSWORD_PROD=${{ secrets.DB_PASSWORD_PROD }}
            
            # Docker Hub에서 방금 올린 최신 버전의 백엔드 이미지를 다운로드(pull)합니다.
            docker compose pull backend
            
            # 최신 이미지를 사용하여 백엔드 컨테이너를 다시 시작합니다. (다른 서비스는 그대로 둡니다)
            # -d 옵션은 백그라운드에서 실행하라는 의미입니다.
            docker compose up -d backend
            
            # 불필요하게 남은 이전 버전의 Docker 이미지를 삭제하여 서버 용량을 확보합니다.
            docker image prune -f
